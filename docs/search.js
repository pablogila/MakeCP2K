window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "thotpy", "modulename": "thotpy", "kind": "module", "doc": "<h1 id=\"thotpy-v542\">ThotPy v5.4.2</h1>\n\n<p>Welcome to the <strong>T</strong>ext en<strong>H</strong>ancement &amp; <strong>O</strong>ptimization for scien<strong>T</strong>ific researc<strong>H</strong> with <strong>PY</strong>thon; or just <strong>ThotPy</strong>, as the modern incarnation of the ancient Egyptian god of writing, wisdom and magic, <a href=\"https://en.wikipedia.org/wiki/Thoth\">Thot</a>.  </p>\n\n<p>This Python3 package allows you to create, edit and analyze all kinds of text files, with a special focus on ab-initio calculations. In particular, it contains interfaces for <a href=\"https://www.quantum-espresso.org/\">Quantum ESPRESSO</a> and <a href=\"https://phonopy.github.io/phonopy/\">Phonopy</a>.</p>\n\n<blockquote>\n  <p><strong>Also check...</strong><br />\n  Just as the ancient Egyptian god, ThotPy is <em>married</em> with <a href=\"https://github.com/pablogila/MaatPy\">MaatPy</a>, another useful python package to analyze spectral data from your experiments. Check it out!<br />\n  Note that ThotPy was formally known as InputMaker.  </p>\n</blockquote>\n\n<h1 id=\"installation\">Installation</h1>\n\n<p>As always, it is recommended to install your packages in a virtual environment:  </p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>python3<span class=\"w\"> </span>-m<span class=\"w\"> </span>venv<span class=\"w\"> </span>.venv\n<span class=\"nb\">source</span><span class=\"w\"> </span>.venv/bin/activate\n</code></pre>\n</div>\n\n<h2 id=\"with-pip\">With PIP</h2>\n\n<p>To install ThotPy with pip, run:  </p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>pip<span class=\"w\"> </span>install<span class=\"w\"> </span>thotpy\n</code></pre>\n</div>\n\n<h2 id=\"from-github\">From GitHub</h2>\n\n<p>Optionally, you can install ThotPy from the last GitHub release. First install the dependencies:  </p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>pip<span class=\"w\"> </span>install<span class=\"w\"> </span>pandas\n</code></pre>\n</div>\n\n<p>Then clone the repository from <a href=\"https://github.com/pablogila/ThotPy/\">GitHub</a> or download it as a ZIP, and run inside the <code>/ThotPy/</code> directory:  </p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>pip<span class=\"w\"> </span>install<span class=\"w\"> </span>.\n</code></pre>\n</div>\n\n<h1 id=\"documentation\">Documentation</h1>\n\n<p>Check the full ThotPy documentation <a href=\"https://pablogila.github.io/ThotPy/\">here</a>.<br />\nAn offline version of the documentation is available in the <code>docs/thotpy.html</code> folder.  </p>\n\n<h2 id=\"submodules\">Submodules</h2>\n\n<p>This package contains the following submodules for general text edition:</p>\n\n<ul>\n<li><code>thotpy.file</code>. Manipulate files.</li>\n<li><code>thotpy.find</code>. Search for specific content in a text file.</li>\n<li><code>thotpy.text</code>. Manipulate text files.</li>\n<li><code>thotpy.extract</code>. Extract data from raw text strings.</li>\n<li><code>thotpy.call</code>. Run bash scripts and related.</li>\n</ul>\n\n<p>Along with the <code>thotpy.core</code> submodule with common utilities.</p>\n\n<h2 id=\"interfaces-for-ab-initio-codes\">Interfaces for ab-initio codes</h2>\n\n<p>The following interfaces for ab-initio codes are included:</p>\n\n<ul>\n<li><code>thotpy.qe</code>. Interface for <a href=\"https://www.quantum-espresso.org/\">Quantum ESPRESSO</a> calculations.</li>\n<li><code>thotpy.phonopy</code>. Interface for <a href=\"https://phonopy.github.io/phonopy/\">Phonopy</a> calculations.</li>\n</ul>\n\n<h2 id=\"compiling-the-documentation\">Compiling the documentation</h2>\n\n<p>The documentation can be compiled automatically using <a href=\"https://pdoc.dev/\">pdoc</a> and ThotPy itself, by running:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>python3<span class=\"w\"> </span>makedocs.py\n</code></pre>\n</div>\n\n<h1 id=\"license\">License</h1>\n\n<p>Copyright (C) 2024  Pablo Gila-Herranz<br />\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the <strong>GNU Affero General Public License</strong> as published\nby the Free Software Foundation, either version <strong>3</strong> of the License, or\n(at your option) any later version.<br />\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.<br />\nSee the attached GNU Affero General Public License for more details.  </p>\n"}, {"fullname": "thotpy.call", "modulename": "thotpy.call", "kind": "module", "doc": "<h1 id=\"description\">Description</h1>\n\n<p>Functions to handle bash calls and related operations on Linux systems.</p>\n\n<h1 id=\"index\">Index</h1>\n\n<ul>\n<li><code>bash()</code></li>\n<li><code>git()</code></li>\n<li><code>here()</code></li>\n</ul>\n\n<hr />\n"}, {"fullname": "thotpy.call.bash", "modulename": "thotpy.call", "qualname": "bash", "kind": "function", "doc": "<p>Run a bash shell <code>command</code>, inside an optional <code>cwd</code> directory.\nIf empty, the current working directory will be used.\nPrints the running command and outputs by default, override this with <code>verbose=False</code>.\nReturns the result of the command used, except for when\nerrors are raised automatically; set <code>return_anyway=True</code> to override this.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">command</span>, </span><span class=\"param\"><span class=\"n\">cwd</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">return_anyway</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "thotpy.call.git", "modulename": "thotpy.call", "qualname": "git", "kind": "function", "doc": "<p>Automatically update a Git repository.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">message</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">tag</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.call.here", "modulename": "thotpy.call", "qualname": "here", "kind": "function", "doc": "<p>Runs the rest of the script inside the specified <code>folder</code>.\nIf none is provided, it runs from the same directory where the current script lies.\nThis is really useful to run scripts from the VSCode terminal, etc.\nReturns the path of the used <code>folder</code>, or the path of the script if folder is not provided.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">folder</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.core", "modulename": "thotpy.core", "kind": "module", "doc": "<h1 id=\"description\">Description</h1>\n\n<p>Common utilities, autoloaded directly as <code>thotpy.value</code>.</p>\n\n<h1 id=\"index\">Index</h1>\n\n<ul>\n<li><code>version</code></li>\n<li><code>help()</code></li>\n</ul>\n\n<hr />\n"}, {"fullname": "thotpy.core.version", "modulename": "thotpy.core", "qualname": "version", "kind": "variable", "doc": "<p>Package version, using semantic versioning to indicate breaking changes,\nas in v<MAJOR>.<MINOR>.<PATCH>.</p>\n", "default_value": "&#x27;v5.4.2&#x27;"}, {"fullname": "thotpy.core.help", "modulename": "thotpy.core", "qualname": "help", "kind": "function", "doc": "<p>Print the help message.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.extract", "modulename": "thotpy.extract", "kind": "module", "doc": "<h1 id=\"description\">Description</h1>\n\n<p>Functions to extract data from raw text strings.</p>\n\n<h1 id=\"index\">Index</h1>\n\n<ul>\n<li><code>number()</code></li>\n<li><code>string()</code></li>\n<li><code>column()</code></li>\n</ul>\n\n<hr />\n"}, {"fullname": "thotpy.extract.number", "modulename": "thotpy.extract", "qualname": "number", "kind": "function", "doc": "<p>Extracts the float value of a given <code>name</code> variable from a raw <code>text</code>.</p>\n\n<p>Example:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">text</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;energy =   500.0 Ry&#39;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">thotpy</span><span class=\"o\">.</span><span class=\"n\">extract</span><span class=\"o\">.</span><span class=\"n\">number</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">,</span> <span class=\"s1\">&#39;energy&#39;</span><span class=\"p\">)</span>\n<span class=\"mf\">500.0</span>  <span class=\"c1\"># float output</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.extract.string", "modulename": "thotpy.extract", "qualname": "string", "kind": "function", "doc": "<p>Extracts the <code>text</code> value of a given <code>name</code> variable from a raw string.\nStops before an optional <code>stop</code> string.\nRemoves leading and trailing commas by default, change this with <code>strip=False</code>.</p>\n\n<p>Example:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">text</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;energy =   500.0 Ry were calculated&#39;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">thotpy</span><span class=\"o\">.</span><span class=\"n\">extract</span><span class=\"o\">.</span><span class=\"n\">string</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">,</span> <span class=\"s1\">&#39;energy&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;were&#39;</span><span class=\"p\">)</span>\n<span class=\"s1\">&#39;500.0 Ry&#39;</span>  <span class=\"c1\"># String output</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>, </span><span class=\"param\"><span class=\"n\">stop</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>, </span><span class=\"param\"><span class=\"n\">strip</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.extract.column", "modulename": "thotpy.extract", "qualname": "column", "kind": "function", "doc": "<p>Extracts the desired float <code>column</code> of a given <code>string</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">column</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.extract.coords", "modulename": "thotpy.extract", "qualname": "coords", "kind": "function", "doc": "<p>Returns a list with the float coordinates expressed in a given <code>text</code> string.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.file", "modulename": "thotpy.file", "kind": "module", "doc": "<h1 id=\"description\">Description</h1>\n\n<p>Functions to move files around.</p>\n\n<h1 id=\"index\">Index</h1>\n\n<ul>\n<li><code>get()</code></li>\n<li><code>get_list()</code></li>\n<li><code>copy()</code></li>\n<li><code>move()</code></li>\n<li><code>remove()</code></li>\n<li><code>rename()</code></li>\n<li><code>rename_on_subfolders()</code></li>\n<li><code>copy_to_subfolders()</code></li>\n<li><code>from_template()</code></li>\n</ul>\n\n<hr />\n"}, {"fullname": "thotpy.file.get", "modulename": "thotpy.file", "qualname": "get", "kind": "function", "doc": "<p>Check if the given <code>filename</code> exists in the currrent working directory\nor in the full path, and returns its full path as a string.</p>\n\n<p>Raises an error if the file is not found, unless <code>return_anyway=True</code>,\nin which case it returns None. This can be used to personalize errors.</p>\n\n<p>If the provided string is a directory, it checks the files inside it.\nif there is only one file inside, it returns said file;\nif there are more files, it tries to filter them with the <code>filters</code> keyword(s) to return a single file.\nIf this fails, try using more strict filers to return a single file.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">filters</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">return_anyway</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.file.get_list", "modulename": "thotpy.file", "qualname": "get_list", "kind": "function", "doc": "<p>Takes a <code>folder</code>, filters the content with the <code>filters</code> keyword(s) if provided, and returns a list with the matches.\nThe full paths are returned by default; to get only the base names, set <code>abspath=False</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">folder</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">filters</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">abspath</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.file.copy", "modulename": "thotpy.file", "qualname": "copy", "kind": "function", "doc": "<p>Copies the content of <code>old</code> file to <code>new</code> file with shutil,\nafter making sure that the file exists with <code>thotpy.file.get()</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">old</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">new</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.file.move", "modulename": "thotpy.file", "qualname": "move", "kind": "function", "doc": "<p>Moves <code>old</code> file to <code>new</code> file.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">old</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">new</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.file.remove", "modulename": "thotpy.file", "qualname": "remove", "kind": "function", "doc": "<p>Removes the given file with <code>filename</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.file.rename", "modulename": "thotpy.file", "qualname": "rename", "kind": "function", "doc": "<p>Batch renames files in the given folder, replacing <code>old</code> string by <code>new</code> string.\nIf no <code>folder</code> is provided, the current working directory is used.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">old</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">new</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">folder</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.file.rename_on_subfolders", "modulename": "thotpy.file", "qualname": "rename_on_subfolders", "kind": "function", "doc": "<p>Renames the files inside the subfolders in the given <code>folder</code>,\nfrom an <code>old</code> string to the <code>new</code> string.\nIf no <code>folder</code> is provided, the current working directory is used.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">old</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">new</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">folder</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.file.copy_to_subfolders", "modulename": "thotpy.file", "qualname": "copy_to_subfolders", "kind": "function", "doc": "<p>Copies the files from the <code>folder</code> with the given <code>extension</code> to individual subfolders.\nThe subfolders are named as the original files,\nremoving the strings from the <code>strings_to_delete</code> list.\nIf no <code>folder</code> is provided, it runs in the current working directory.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">folder</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">extension</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">strings_to_delete</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"p\">[]</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.file.from_template", "modulename": "thotpy.file", "qualname": "from_template", "kind": "function", "doc": "<p>Similar to <code>copy_file()</code>, but optionally adds a <code>comment</code> at the beginning of the new file.\nAlso, it optionally corrects the output file with a <code>fixing_dict</code> dictionary.\n<code>old</code> is the template and <code>new</code> is the final file.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">old</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">new</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">comment</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">fixing_dict</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.find", "modulename": "thotpy.find", "kind": "module", "doc": "<h1 id=\"description\">Description</h1>\n\n<p>Functions to search for specific content inside text files.</p>\n\n<h1 id=\"index\">Index</h1>\n\n<ul>\n<li><code>lines()</code></li>\n<li><code>between()</code></li>\n<li><code>pos()</code></li>\n<li><code>pos_regex()</code></li>\n<li><code>next_pos()</code></li>\n<li><code>next_pos_regex()</code></li>\n<li><code>line_pos()</code></li>\n<li><code>between_pos()</code></li>\n</ul>\n\n<hr />\n"}, {"fullname": "thotpy.find.lines", "modulename": "thotpy.find", "qualname": "lines", "kind": "function", "doc": "<p>Finds the line(s) containing the <code>key</code> string in the given file with <code>filename</code>,\nreturning a list with the matches.</p>\n\n<p>The value <code>matches</code> specifies the max number of matches to be returned.\nDefaults to 0 to return all possible matches. Set it to 1 to return only one match,\nor to negative integers to start the search from the end of the file upwards.</p>\n\n<p>The value <code>additional</code> specifies the number of additional lines\nbelow the target line that are also returned;\n2 to return the found line plus two additional lines below, etc.\nNegative values return the specified number of lines before the target line.\nThe original ordering from the file is preserved.\nDefaults to <code>additional=0</code>, only returning the target line.\nBy default, the additional lines are returned in the same list item as the match separated by a <code>\\n</code>,\nunless <code>split=True</code>, in which case these additional lines are added as additional items in the list.</p>\n\n<p>To use regular expressions in the search, set <code>regex=True</code>.\nBy default regex search is deactivated, using the faster mmap.find and rfind methods instead.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">matches</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">additional</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">split</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">regex</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.find.between", "modulename": "thotpy.find", "qualname": "between", "kind": "function", "doc": "<p>Returns the content between the lines with <code>key1</code> and <code>key2</code> in the given file with <code>filename</code>.\nKeywords can be at any position within the line.\nRegular expressions can be used by setting <code>regex=True</code>.</p>\n\n<p>Key lines are omited by default, but can be returned with <code>include_keys=True</code>.</p>\n\n<p>If there is more than one match, only the first one is considered by default;\nset <code>match</code> (int) to specify a particular match (1, 2... 0 is considered as 1!).\nUse negative numbers to start from the end of the file.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">key1</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">key2</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">include_keys</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">match</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">regex</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.find.pos", "modulename": "thotpy.find", "qualname": "pos", "kind": "function", "doc": "<p>Returns a list of the positions of a <code>key</code> in a given <code>filename</code> (whether file or memory mapped file).</p>\n\n<p>The value <code>matches</code> specifies the max number of matches to return.\nDefaults to 0 to return all possible matches. Set it to 1 to return only one match,\nor to negative integers to start searching from the end of the file upwards.</p>\n\n<p>This method is faster than <code>pos_regex()</code>, but does not search for regular expressions.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">filename</span>, </span><span class=\"param\"><span class=\"n\">matches</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.find.pos_regex", "modulename": "thotpy.find", "qualname": "pos_regex", "kind": "function", "doc": "<p>Returns a list of the positions of a <code>key</code> in a given file with <code>filename</code> (actual file, not mmapped!).</p>\n\n<p>The value <code>matches</code> specifies the max number of matches to return.\nDefaults to 0 to return all possible matches. Set it to 1 to return only one match,\nor to negative integers to start searching from the end of the file upwards.</p>\n\n<p>This method is slower than <code>pos()</code>, but it can search for regular expressions.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">filename</span>, </span><span class=\"param\"><span class=\"n\">matches</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.find.next_pos", "modulename": "thotpy.find", "qualname": "next_pos", "kind": "function", "doc": "<p>Returns the next position of the <code>key</code> string in the given file with <code>filename</code> (file or mmapped file),\nstarting from an initial <code>position</code> tuple.\nThe <code>match</code> number specifies the nonzero index of the next match to return (1, 2... 0 is considered as 1!).\nIt can be negative to search backwards from the initial position.\nThe last known positions will be returned if no more matches are found.</p>\n\n<p>This method is specific for normal strings.\nTo use regular expressions, check <code>next_pos_regex()</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">position</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span>, </span><span class=\"param\"><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">filename</span>, </span><span class=\"param\"><span class=\"n\">match</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.find.next_pos_regex", "modulename": "thotpy.find", "qualname": "next_pos_regex", "kind": "function", "doc": "<p>Returns the next position of the <code>key</code> string in the given file with <code>filename</code>\n(actual file, not mmapped!), starting from an initial <code>position</code> tuple.\nThe <code>match</code> number specifies the next match to return (1, 2... 0 is considered as 1!).\nIt can be negative to search backwards from the initial position.\nThis method is specific for regular expressions.</p>\n\n<p>For normal strings, check the faster <code>next_pos()</code> method.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">position</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span>, </span><span class=\"param\"><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">filename</span>, </span><span class=\"param\"><span class=\"n\">match</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.find.line_pos", "modulename": "thotpy.find", "qualname": "line_pos", "kind": "function", "doc": "<p>Returns the position of the full line containing the <code>position</code> tuple,\nin the given file with <code>filename</code> (whether file or memory mapped file).\nA specific line below can be returned with <code>skips</code> being a natural int,\nor previous lines with negative values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">position</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span>, </span><span class=\"param\"><span class=\"n\">filename</span>, </span><span class=\"param\"><span class=\"n\">skips</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.find.between_pos", "modulename": "thotpy.find", "qualname": "between_pos", "kind": "function", "doc": "<p>Deletes the content between the line containing the <code>key1</code> and <code>key2</code> in the given file with <code>filename</code>.\nKeywords can be at any position within the line.\nRegular expressions can be used by setting <code>regex=True</code>.</p>\n\n<p>Key lines are omited by default, but can be returned with <code>include_keys=True</code>.</p>\n\n<p>If there is more than one match, only the first one is considered by default;\nset <code>match</code> number to specify a particular match (1, 2... 0 is considered as 1!).\nUse negative numbers to start from the end of the file.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">key1</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">key2</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">filename</span>,</span><span class=\"param\">\t<span class=\"n\">include_keys</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">match</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">regex</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.phonopy", "modulename": "thotpy.phonopy", "kind": "module", "doc": "<h1 id=\"description\">Description</h1>\n\n<p>Functions to work with <a href=\"https://phonopy.github.io/phonopy/\">Phonopy</a> calculations,\nalong with <a href=\"https://www.quantum-espresso.org/\">Quantum ESPRESSO</a>.</p>\n\n<h1 id=\"index\">Index</h1>\n\n<p>The two main functions that you might want to use to run phonon calculations are:  </p>\n\n<ul>\n<li><code>make()</code> Build the supercell inputs.</li>\n<li><code>sbatch()</code> Sbatch'es the supercell calculations.</li>\n</ul>\n\n<p>The following functions are available for whoever seeks more control:</p>\n\n<ul>\n<li><code>supercells_from_scf()</code></li>\n<li><code>scf_header_to_supercells()</code></li>\n<li><code>check_slurm_template()</code></li>\n</ul>\n\n<hr />\n"}, {"fullname": "thotpy.phonopy.make", "modulename": "thotpy.phonopy", "qualname": "make", "kind": "function", "doc": "<p>Starting on a given <code>folder</code> (CWD if none) from the <code>relax_in</code> and <code>relax_out</code> (default ones),\ncreates the supercells of a <code>dimension</code> (<code>2 2 2</code> by default)\nneeded for the Phonopy calculations with Quantum ESPRESSO.\nIt runs sequentially <code>scf_from_relax()</code>, <code>supercells_from_scf()</code> and <code>scf_header_to_supercells()</code>.\nFinally, it checks the <code>slurm_template</code> with <code>check_slurm_template()</code>.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dimension</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;2 2 2&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">folder</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">relax_in</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;relax.in&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">relax_out</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;relax.out&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">slurm_template</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;scf.slurm&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.phonopy.sbatch", "modulename": "thotpy.phonopy", "qualname": "sbatch", "kind": "function", "doc": "<p>Launch all your supercell calculations to a cluster using a SLURM manager.\nRuns from a <code>folder</code> (CWD if empty), using a <code>slurm_template</code> (<code>scf.slurm</code> by default).</p>\n\n<p>The slurm template must have the following keywords: <code>INPUT_FILE</code>, <code>OUTPUT_FILE</code>, and <code>JOB_NAME</code>.</p>\n\n<p>If <code>testing=True</code> it skips the final sbatching, just printing the commands on the screen.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">folder</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">slurm_template</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;scf.slurm&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">testing</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.phonopy.supercells_from_scf", "modulename": "thotpy.phonopy", "qualname": "supercells_from_scf", "kind": "function", "doc": "<p>Creates supercells of a given <code>dimension</code> (<code>2 2 2</code> by default) inside a <code>folder</code>,\nfrom a Quantum ESPRESSO <code>scf</code> input (<code>scf.in</code> by default).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dimension</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;2 2 2&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">folder</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">scf</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;scf.in&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.phonopy.scf_header_to_supercells", "modulename": "thotpy.phonopy", "qualname": "scf_header_to_supercells", "kind": "function", "doc": "<p>Paste the header from the <code>scf</code> file in <code>folder</code> to the supercells created by Phonopy.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">folder</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">scf</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;scf.in&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.phonopy.check_slurm_template", "modulename": "thotpy.phonopy", "qualname": "check_slurm_template", "kind": "function", "doc": "<p>Check a <code>slurm_template</code> inside <code>folder</code>.\nThe current working directory is used if <code>folder</code> is not provided.\nIf the file does not exist or is invalid, creates a <code>scf_EXAMPLE.slurm</code> file for reference.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">folder</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">slurm_template</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;scf.slurm&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.qe", "modulename": "thotpy.qe", "kind": "module", "doc": "<h1 id=\"description\">Description</h1>\n\n<p>Functions to work with <a href=\"https://www.quantum-espresso.org/\">Quantum ESPRESSO</a> calculation files.</p>\n\n<h1 id=\"index\">Index</h1>\n\n<ul>\n<li><code>pw_description</code></li>\n<li><code>read_in()</code></li>\n<li><code>read_out()</code></li>\n<li><code>read_dir()</code></li>\n<li><code>read_dirs()</code></li>\n<li><code>set_value()</code></li>\n<li><code>scf_from_relax()</code></li>\n</ul>\n\n<hr />\n"}, {"fullname": "thotpy.qe.pw_description", "modulename": "thotpy.qe", "qualname": "pw_description", "kind": "variable", "doc": "<p>Dictionary with every possible namelist as keys, and the corresponding variables as values.</p>\n", "default_value": "{&#x27;&amp;CONTROL&#x27;: [&#x27;calculation&#x27;, &#x27;title&#x27;, &#x27;verbosity&#x27;, &#x27;restart_mode&#x27;, &#x27;wf_collect&#x27;, &#x27;nstep&#x27;, &#x27;iprint&#x27;, &#x27;tstress&#x27;, &#x27;tprnfor&#x27;, &#x27;dt&#x27;, &#x27;outdir&#x27;, &#x27;wfcdir&#x27;, &#x27;prefix&#x27;, &#x27;lkpoint_dir&#x27;, &#x27;max_seconds&#x27;, &#x27;etot_conv_thr&#x27;, &#x27;forc_conv_thr&#x27;, &#x27;disk_io&#x27;, &#x27;pseudo_dir&#x27;, &#x27;tefield&#x27;, &#x27;dipfield&#x27;, &#x27;lelfield&#x27;, &#x27;nberrycyc&#x27;, &#x27;lorbm&#x27;, &#x27;lberry&#x27;, &#x27;gdir&#x27;, &#x27;nppstr&#x27;, &#x27;gate&#x27;, &#x27;twochem&#x27;, &#x27;lfcp&#x27;, &#x27;trism&#x27;], &#x27;&amp;SYSTEM&#x27;: [&#x27;ibrav&#x27;, &#x27;celldm(1)&#x27;, &#x27;celldm(2)&#x27;, &#x27;celldm(3)&#x27;, &#x27;celldm(4)&#x27;, &#x27;celldm(5)&#x27;, &#x27;celldm(6)&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;cosAB&#x27;, &#x27;cosAC&#x27;, &#x27;cosBC&#x27;, &#x27;nat&#x27;, &#x27;ntyp&#x27;, &#x27;nbnd&#x27;, &#x27;nbnd_cond&#x27;, &#x27;tot_charge&#x27;, &#x27;starting_charge&#x27;, &#x27;tot_magnetization&#x27;, &#x27;starting_magnetization&#x27;, &#x27;ecutwfc&#x27;, &#x27;ecutrho&#x27;, &#x27;ecutfock&#x27;, &#x27;nr1&#x27;, &#x27;nr2&#x27;, &#x27;nr3&#x27;, &#x27;nr1s&#x27;, &#x27;nr2s&#x27;, &#x27;nr3s&#x27;, &#x27;nosym&#x27;, &#x27;nosym_evc&#x27;, &#x27;noinv&#x27;, &#x27;no_t_rev&#x27;, &#x27;force_symmorphic&#x27;, &#x27;use_all_frac&#x27;, &#x27;occupations&#x27;, &#x27;one_atom_occupations&#x27;, &#x27;starting_spin_angle&#x27;, &#x27;degauss_cond&#x27;, &#x27;nelec_cond&#x27;, &#x27;degauss&#x27;, &#x27;smearing&#x27;, &#x27;nspin&#x27;, &#x27;sic_gamma&#x27;, &#x27;pol_type&#x27;, &#x27;sic_energy&#x27;, &#x27;sci_vb&#x27;, &#x27;sci_cb&#x27;, &#x27;noncolin&#x27;, &#x27;ecfixed&#x27;, &#x27;qcutz&#x27;, &#x27;q2sigma&#x27;, &#x27;input_dft&#x27;, &#x27;ace&#x27;, &#x27;exx_fraction&#x27;, &#x27;screening_parameter&#x27;, &#x27;exxdiv_treatment&#x27;, &#x27;x_gamma_extrapolation&#x27;, &#x27;ecutvcutnqx1&#x27;, &#x27;nqx2&#x27;, &#x27;nqx3&#x27;, &#x27;localization_thr&#x27;, &#x27;Hubbard_occ&#x27;, &#x27;Hubbard_alpha&#x27;, &#x27;Hubbard_beta&#x27;, &#x27;starting_ns_eigenvalue&#x27;, &#x27;dmft&#x27;, &#x27;dmft_prefix&#x27;, &#x27;ensemble_energies&#x27;, &#x27;edir&#x27;, &#x27;emaxpos&#x27;, &#x27;eopreg&#x27;, &#x27;eamp&#x27;, &#x27;angle1&#x27;, &#x27;angle2&#x27;, &#x27;lforcet&#x27;, &#x27;constrained_magnetization&#x27;, &#x27;fixed_magnetization&#x27;, &#x27;lambda&#x27;, &#x27;report&#x27;, &#x27;lspinorb&#x27;, &#x27;assume_isolated&#x27;, &#x27;esm_bc&#x27;, &#x27;esm_w&#x27;, &#x27;esm_efield&#x27;, &#x27;esm_nfit&#x27;, &#x27;lgcscf&#x27;, &#x27;gcscf_mu&#x27;, &#x27;gcscf_conv_thr&#x27;, &#x27;gcscf_beta&#x27;, &#x27;vdw_corr&#x27;, &#x27;london&#x27;, &#x27;london_s6&#x27;, &#x27;london_c6&#x27;, &#x27;london_rvdw&#x27;, &#x27;london_rcut&#x27;, &#x27;dftd3_version&#x27;, &#x27;dftd3_threebody&#x27;, &#x27;ts_vdw_econv_thr&#x27;, &#x27;ts_vdw_isolated&#x27;, &#x27;xdm&#x27;, &#x27;xdm_a1&#x27;, &#x27;xdm_a2&#x27;, &#x27;space_group&#x27;, &#x27;uniqueb&#x27;, &#x27;origin_choice&#x27;, &#x27;rhombohedral&#x27;, &#x27;zgate&#x27;, &#x27;relaxz&#x27;, &#x27;block&#x27;, &#x27;block_1&#x27;, &#x27;block_2&#x27;, &#x27;block_height&#x27;, &#x27;nextffield&#x27;], &#x27;&amp;ELECTRONS&#x27;: [&#x27;electron_maxstep&#x27;, &#x27;exx_maxstep&#x27;, &#x27;scf_must_converge&#x27;, &#x27;conv_thr&#x27;, &#x27;adaptive_thr&#x27;, &#x27;conv_thr_init&#x27;, &#x27;conv_thr_multi&#x27;, &#x27;mixing_mode&#x27;, &#x27;mixing_beta&#x27;, &#x27;mixing_ndim&#x27;, &#x27;mixing_fixed_ns&#x27;, &#x27;diagonalization&#x27;, &#x27;diago_thr_init&#x27;, &#x27;diago_cg_maxiter&#x27;, &#x27;diago_ppcg_maxiter&#x27;, &#x27;diago_david_ndim&#x27;, &#x27;diago_rmm_ndim&#x27;, &#x27;diago_rmm_conv&#x27;, &#x27;diago_gs_nblock&#x27;, &#x27;diago_full_acc&#x27;, &#x27;efield&#x27;, &#x27;efield_cart&#x27;, &#x27;efield_phase&#x27;, &#x27;startingpot&#x27;, &#x27;startingwfc&#x27;, &#x27;tqr&#x27;, &#x27;real_space&#x27;], &#x27;&amp;IONS&#x27;: [&#x27;ion_positions&#x27;, &#x27;ion_velocities&#x27;, &#x27;ion_dynamics&#x27;, &#x27;pot_extrapolation&#x27;, &#x27;wfc_extrapolation&#x27;, &#x27;remove_rigid_rot&#x27;, &#x27;ion_temperature&#x27;, &#x27;tempw&#x27;, &#x27;tolp&#x27;, &#x27;delta_t&#x27;, &#x27;nraise&#x27;, &#x27;refold_pos&#x27;, &#x27;upscale&#x27;, &#x27;bfgs_ndim&#x27;, &#x27;trust_radius_max&#x27;, &#x27;trust_radius_min&#x27;, &#x27;trust_radius_ini&#x27;, &#x27;w_1&#x27;, &#x27;w_2&#x27;, &#x27;fire_alpha_init&#x27;, &#x27;fire_falpha&#x27;, &#x27;fire_nmin&#x27;, &#x27;fire_f_inc&#x27;, &#x27;fire_f_dec&#x27;, &#x27;fire_dtmax&#x27;], &#x27;&amp;CELL&#x27;: [&#x27;cell_dynamics&#x27;, &#x27;press&#x27;, &#x27;wmass&#x27;, &#x27;cell_factor&#x27;, &#x27;press_conv_thrcell_dofree&#x27;], &#x27;&amp;FCP&#x27;: [&#x27;fcp_mu&#x27;, &#x27;fcp_dynamics&#x27;, &#x27;fcp_conv_thr&#x27;, &#x27;fcp_ndiis&#x27;, &#x27;fcp_mass&#x27;, &#x27;fcp_velocity&#x27;, &#x27;fcp_temperature&#x27;, &#x27;fcp_tempw&#x27;, &#x27;fcp_tolp &#x27;, &#x27;fcp_delta_t&#x27;, &#x27;fcp_nraise&#x27;, &#x27;freeze_all_atoms&#x27;], &#x27;&amp;RISM&#x27;: [&#x27;nsolv&#x27;, &#x27;closure&#x27;, &#x27;tempv&#x27;, &#x27;ecutsolv&#x27;, &#x27;solute_lj&#x27;, &#x27;solute_epsilon&#x27;, &#x27;solute_sigma&#x27;, &#x27;starting1d&#x27;, &#x27;starting3d&#x27;, &#x27;smear1d&#x27;, &#x27;smear3d&#x27;, &#x27;rism1d_maxstep&#x27;, &#x27;rism3d_maxstep&#x27;, &#x27;rism1d_conv_thr&#x27;, &#x27;rism3d_conv_thr&#x27;, &#x27;mdiis1d_size&#x27;, &#x27;mdiis3d_size&#x27;, &#x27;mdiis1d_step&#x27;, &#x27;mdiis3d_step&#x27;, &#x27;rism1d_bond_width&#x27;, &#x27;rism1d_dielectric&#x27;, &#x27;rism1d_molesize&#x27;, &#x27;rism1d_nproc&#x27;, &#x27;rism3d_conv_level&#x27;, &#x27;rism3d_planar_average&#x27;, &#x27;laue_nfit&#x27;, &#x27;laue_expand_right&#x27;, &#x27;laue_expand_left&#x27;, &#x27;laue_starting_right&#x27;, &#x27;laue_starting_left&#x27;, &#x27;laue_buffer_right&#x27;, &#x27;laue_buffer_left&#x27;, &#x27;laue_both_hands&#x27;, &#x27;laue_wall&#x27;, &#x27;laue_wall_z&#x27;, &#x27;laue_wall_rho&#x27;, &#x27;laue_wall_epsilon&#x27;, &#x27;laue_wall_sigma&#x27;, &#x27;laue_wall_lj6&#x27;], &#x27;ATOMIC_SPECIES&#x27;: [&#x27;X&#x27;, &#x27;Mass_X&#x27;, &#x27;PseudoPot_X&#x27;], &#x27;ATOMIC_POSITIONS&#x27;: [&#x27;X&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;if_pos(1)&#x27;, &#x27;if_pos(2)&#x27;, &#x27;if_pos(3)&#x27;], &#x27;K_POINTS&#x27;: [&#x27;nks&#x27;, &#x27;xk_x&#x27;, &#x27;xk_y&#x27;, &#x27;xk_z&#x27;, &#x27;wk&#x27;, &#x27;nk1&#x27;, &#x27;nk2&#x27;, &#x27;nk3&#x27;, &#x27;sk1&#x27;, &#x27;sk2&#x27;, &#x27;sk3&#x27;], &#x27;ADDITIONAL_K_POINTS&#x27;: [&#x27;nks_add&#x27;, &#x27;k_x&#x27;, &#x27;k_y&#x27;, &#x27;k_z&#x27;, &#x27;wk_&#x27;], &#x27;CELL_PARAMETERS&#x27;: [&#x27;v1&#x27;, &#x27;v2&#x27;, &#x27;v3&#x27;], &#x27;CONSTRAINTS&#x27;: [&#x27;nconstr&#x27;, &#x27;constr_tol&#x27;, &#x27;constr_type&#x27;, &#x27;constr(1)&#x27;, &#x27;constr(2)&#x27;, &#x27;constr(3)&#x27;, &#x27;constr(4)&#x27;, &#x27;constr_target&#x27;], &#x27;OCCUPATIONS&#x27;: [&#x27;f_inp1&#x27;, &#x27;f_inp2&#x27;], &#x27;ATOMIC_VELOCITIES&#x27;: [&#x27;V&#x27;, &#x27;vx&#x27;, &#x27;vy&#x27;, &#x27;vz&#x27;], &#x27;ATOMIC_FORCES&#x27;: [&#x27;X&#x27;, &#x27;fx&#x27;, &#x27;fy&#x27;, &#x27;fz&#x27;], &#x27;SOLVENTS&#x27;: [&#x27;X&#x27;, &#x27;Density&#x27;, &#x27;Molecule&#x27;, &#x27;X&#x27;, &#x27;Density_Left&#x27;, &#x27;Density_Right&#x27;, &#x27;Molecule&#x27;], &#x27;HUBBARD&#x27;: [&#x27;label(1)-manifold(1)&#x27;, &#x27;u_val(1)&#x27;, &#x27;label(1)-manifold(1)&#x27;, &#x27;j0_val(1)&#x27;, &#x27;paramType(1)&#x27;, &#x27;label(1)-manifold(1)&#x27;, &#x27;paramValue(1)&#x27;, &#x27;label(I)-manifold(I)&#x27;, &#x27;u_val(I)&#x27;, &#x27;label(I)-manifold(I)&#x27;, &#x27;j0_val(I)&#x27;, &#x27;label(I)-manifold(I)&#x27;, &#x27;label(J)-manifold(J)&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;v_val(I,J)&#x27;]}"}, {"fullname": "thotpy.qe.read_in", "modulename": "thotpy.qe", "qualname": "read_in", "kind": "function", "doc": "<p>Reads an input <code>filename</code> from Quantum ESPRESSO,\nreturning a dictionary with the input values used.\nThe keys are named after the name of the corresponding variable.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.qe.read_out", "modulename": "thotpy.qe", "qualname": "read_out", "kind": "function", "doc": "<p>Reads an output <code>filename</code> from Quantum ESPRESSO,\nreturning a dict with the following keys:\n<code>'Energy'</code> (float), <code>'Total force'</code> (float), <code>'Total SCF correction'</code> (float),\n<code>'Runtime'</code> (str), <code>'JOB DONE'</code> (bool), <code>'BFGS converged'</code> (bool), <code>'BFGS failed'</code> (bool),\n<code>'Maxiter reached'</code> (bool), <code>'Error'</code> (str), <code>'Success'</code> (bool), <code>'CELL_PARAMETERS_out'</code> (list of str), <code>'ATOMIC_POSITIONS_out'</code> (list of str), <code>'alat'</code> (float).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.qe.read_dir", "modulename": "thotpy.qe", "qualname": "read_dir", "kind": "function", "doc": "<p>Takes a <code>folder</code> containing a Quantum ESPRESSO calculation,\nand returns a dictionary containing the input parameters and output results.\nInput and output files are determined automatically,\nbut must be specified with <code>in_str</code> and <code>out_str</code> if more than one file ends with <code>.in</code> or <code>.out</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">folder</span>, </span><span class=\"param\"><span class=\"n\">in_str</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;.in&#39;</span>, </span><span class=\"param\"><span class=\"n\">out_str</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;.out&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.qe.read_dirs", "modulename": "thotpy.qe", "qualname": "read_dirs", "kind": "function", "doc": "<p>Calls recursively <code>read_dir()</code>, reading Quantum ESPRESSO calculations\nfrom all the subfolders inside the given <code>directory</code>.\nThe results are saved to CSV files inside the current directory.\nInput and output files are determined automatically, but must be specified with\n<code>in_str</code> and <code>out_str</code> if more than one file ends with <code>.in</code> or <code>.out</code>.</p>\n\n<p>To properly group the calculations per type, saving separated CSVs for each calculation type,\nyou can modify <code>calc_splitter</code> ('_' by default), <code>calc_type_index</code> (0) and <code>calc_id_index</code> (1).\nWith these default values, a subfolder named './CalculationType_CalculationID_AdditionalText/'\nwill be interpreted as follows:</p>\n\n<ul>\n<li>Calculation type: 'CalculationType' (The output CSV will be named after this)</li>\n<li>CalculationID: 'CalculationID' (Stored in the 'ID' column of the resulting dataframe)</li>\n</ul>\n\n<p>If everything fails, the subfolder name will be used.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">directory</span>,</span><span class=\"param\">\t<span class=\"n\">in_str</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;.in&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">out_str</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;.out&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">calc_splitter</span><span class=\"o\">=</span><span class=\"s1\">&#39;_&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">calc_type_index</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">calc_id_index</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.qe.set_value", "modulename": "thotpy.qe", "qualname": "set_value", "kind": "function", "doc": "<p>Replace the <code>value</code> of a <code>key</code> parameter in an input file with <code>filename</code>.\nIf <code>value=''</code>, the parameter gets deleted.</p>\n\n<p>Remember to include the upper commas <code>'</code> on values that use them.</p>\n\n<p>Note that you must update some values before replacing others:\n'nat' before 'ATOMIC_POSITIONS', 'ntyp' before 'ATOMIC_SPECIES',\nand lattice parameters before 'CELL_PARAMETERS.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span>, </span><span class=\"param\"><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">filename</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.qe.scf_from_relax", "modulename": "thotpy.qe", "qualname": "scf_from_relax", "kind": "function", "doc": "<p>Create a Quantum ESPRESSO <code>scf.in</code> file from a previous relax calculation.\nIf no <code>folder</code> is provided, the current working directory is used.\nThe <code>relax_in</code> and <code>relax_out</code> files by default are <code>relax.in</code> and <code>relax.out</code>,\nupdate the names if necessary.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">folder</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">relax_in</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;relax.in&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">relax_out</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;relax.out&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.text", "modulename": "thotpy.text", "kind": "module", "doc": "<h1 id=\"description\">Description</h1>\n\n<p>Functions to manipulate text files.</p>\n\n<h1 id=\"index\">Index</h1>\n\n<ul>\n<li><code>insert_at()</code></li>\n<li><code>insert_under()</code></li>\n<li><code>replace()</code></li>\n<li><code>replace_line()</code></li>\n<li><code>replace_between()</code></li>\n<li><code>delete_under()</code></li>\n<li><code>correct_with_dict()</code></li>\n</ul>\n\n<hr />\n"}, {"fullname": "thotpy.text.insert_at", "modulename": "thotpy.text", "qualname": "insert_at", "kind": "function", "doc": "<p>Inserts a <code>text</code> in the line with <code>position</code> index of a given file indicated in <code>filename</code>.\nIf <code>position</code> is negative, starts from the end of the file.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">filename</span>, </span><span class=\"param\"><span class=\"n\">position</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.text.insert_under", "modulename": "thotpy.text", "qualname": "insert_under", "kind": "function", "doc": "<p>Inserts the given <code>text</code> string under the line(s) containing\nthe <code>key</code> in the given file at <code>filename</code>.\nThe keyword can be at any position within the line.\nBy default all matches are inserted with <code>insertions=0</code>,\nbut it can insert only a specific number of matches\nwith positive numbers (1, 2...), or starting from the bottom with negative numbers.\nThe text can be introduced after a specific number of lines after the match,\nchanging the value <code>skips</code>. Negative integers introduce the text in the previous lines.\nRegular expressions can be used by setting <code>regex=True</code>.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">filename</span>,</span><span class=\"param\">\t<span class=\"n\">insertions</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">skips</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">regex</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.text.replace", "modulename": "thotpy.text", "qualname": "replace", "kind": "function", "doc": "<p>Replaces the <code>key</code> string with the <code>text</code> string in the specified <code>filename</code>.</p>\n\n<p>It can also be used to delete the keyword with <code>text=''</code>.</p>\n\n<p>The value <code>replacements</code> specifies the number of replacements to perform:\n1 to replace only the first keyword found, 2, 3...\nUse negative values to replace from the end of the file,\neg. to replace the last found key, use <code>replacements=-1</code>.\nTo replace all values, set <code>replacements = 0</code>, which is the value by default.</p>\n\n<p>To search with regular expressions, set <code>regex=True</code>.</p>\n\n<pre><code>line... key ...line -&gt; line... text ...line\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">replacements</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">regex</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.text.replace_line", "modulename": "thotpy.text", "qualname": "replace_line", "kind": "function", "doc": "<p>Replaces the entire line(s) containing the <code>key</code> string with the <code>text</code> string in the specified <code>filename</code>.\nRegular expressions can be used with <code>regex=True</code>.</p>\n\n<p>It can be used to delete line(s) by setting <code>text=''</code>.</p>\n\n<p>The value <code>replacements</code> specifies the number of lines to replace:\n1 to replace only the first line with the keyword, 2, 3...\nUse negative values to replace from the end of the file,\ne.g., to replace only the last line containing the keyword, use <code>replacements = -1</code>.\nTo replace all lines, set <code>replacements = 0</code>, which is the value by default.</p>\n\n<p>The default line to replace is the matching line,\nbut it can be any other specific line after or before the matching line;\nthis is indicated with <code>skips</code> as a positive or negative integer.</p>\n\n<p>More lines can be replaced with <code>additional</code> lines (int).\nNote that the matched line plus the additional lines will be replaced, this is, additional lines +1.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">replacements</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">skips</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">additional</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">regex</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.text.replace_between", "modulename": "thotpy.text", "qualname": "replace_between", "kind": "function", "doc": "<p>Replace lines with a given <code>text</code>, between the keywords <code>key1</code> and <code>key2</code> in a specified <code>filename</code>.</p>\n\n<p>It can be used to delete the text between the keys by setting <code>text=''</code>.</p>\n\n<p>Regular expressions can be used by setting <code>regex=True</code>.</p>\n\n<p>Key lines are also deleted if <code>delete_keys=True</code>.</p>\n\n<p>Only the first matches of the keywords are used by default;\nyou can use the last ones with <code>from_end = True</code>.</p>\n\n<pre><code>lines...\nkey1\ntext\nkey2\nlines...\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">text</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">key1</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">key2</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">delete_keys</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">from_end</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">regex</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.text.delete_under", "modulename": "thotpy.text", "qualname": "delete_under", "kind": "function", "doc": "<p>Deletes all the content under the line containing the <code>key</code> in the specified <code>filename</code>.\nThe keyword can be at any position within the line.\nRegular expressions can be used by setting <code>regex=True</code>.</p>\n\n<p>By default the first <code>matches</code> is used; it can be any positive integer (0 is treated as 1!),\nincluding negative integers to select a match starting from the end of the file.</p>\n\n<p>The content can be deleted after a specific number of lines after the match,\nchanging the value <code>skips</code>, that skips the specified number of lines.\nNegative integers start deleting the content from the previous lines.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">filename</span>,</span><span class=\"param\">\t<span class=\"n\">matches</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">skips</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">regex</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "thotpy.text.correct_with_dict", "modulename": "thotpy.text", "qualname": "correct_with_dict", "kind": "function", "doc": "<p>Corrects the given text file <code>filename</code> using a <code>dictionary</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">dictionary</span><span class=\"p\">:</span> <span class=\"nb\">dict</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();